---
date: 03.09.2025
tags:
  - gameplay
  - pcg
---
---

# Quest Trigger Placement

## Goal & Intent
Оптимальное размещение сценарных точек (триггеров квестов, NPC, событий) на сгенерированном графе топологии локации в соответствии с повествовательными и геймплейными требованиями.
**Намерение:** Обеспечить сбалансированный и увлекательный темп игры, логичную последовательность событий и соблюдение авторского замысла, заданного в сценарной базе данных, при сохранении процедурной вариативности. Механика гарантирует, что ключевые точки не будут скученны или, наоборот, слишком разбросаны, а также что конфликтующие события (например, враждующие фракции) будут размещены на достаточном расстоянии друг от друга.

## Trigger / Prerequisites
*   **Входные данные:** 
    1.  Граф топологии локации (массив узлов `knots` и список смежности `adjacency_list`), полученный от механики [[PLTG]].
    2.  Данные из файла сценарной базы `DomainDatabase.json`.
*   **Триггер:** Механика запускается сразу после успешной генерации топологии локации и парсинга `DomainDatabase.json`.
*   **Предварительные условия:** Наличие реализованного генетического алгоритма (`QuestPlacement`), структур данных (`Chromosome`) и предварительно вычисленных матриц расстояний между узлами.

## Input
*   **Топология:** `std::vector<Knot> knots`, `std::unordered_map<Knot, std::vector<Knot>> adjacency_list`.
*   **Сценарий:** Данные, загруженные из `DomainDatabase.json`:
    *   `tag_list`: Список тегов для размещения.
    *   `desired_distances`: Желаемые расстояния в "ребрах графа" от точки `spawn` для каждого тега.
    *   `min_distance_constraints`: Минимальные расстояния между парами тегов.
    *   `spawn_node_id`, `asylum_node_id`, `exit_node_id`: ID узлов, заранее вычисленных для фиксированных точек.

## Execution / Process
Процесс представляет собой работу генетического алгоритма (ГА):

1.  **Предварительные вычисления:**
    *   С помощью BFS (поиска в ширину) вычисляется вектор `distances` — расстояние в шагах от узла `spawn` до всех остальных узлов графа.
    *   С помощью алгоритма Флойда-Уоршалла строится матрица `dist_matrix` кратчайших путей между всеми парами узлов.

2.  **Инициализация популяции** (`initialize_population`):
    *   Создается популяция из `P = 100` хромосом (`Chromosome`).
    *   Каждая хромосома — это вектор `node_ids`, где каждый индекс соответствует тегу из `tag_list`, а значение — ID узла, на который этот тег размещен.
    *   Теги `spawn`, `asylum`, `exit` фиксируются на заранее определенных узлах. Остальным тегам случайным образом назначаются уникальные узлы.

3.  **Оценка приспособленности**(`compute_fitness`):
    Для каждой хромосомы вычисляется значение функции приспособленности:
    *   **Штраф за невалидность:** Если назначения не уникальны или фиксированные теги размещены не на своих узлах, fitness = `-1e9`.
    *   **Основная цель:** Минимизация отклонения фактического расстояния тега от `spawn` от желаемого (`desired`). `fitness -= abs(actual_distance - desired)`.
    *   **Ограничения:** Штраф за нарушение минимальных расстояний между тегами. `fitness -= (min_dist - actual_dist) * 10.0f`.

4.  **Формирование нового поколения:**
    *   **Отбор **(`tournament_selection`): Особи для скрещивания отбираются на основе турнирного отбора с вероятностью, пропорциональной квадрату ранга внутри турнира.
    *   **Скрещивание** (`crossover`): Две родительские хромосомы обмениваются генами (назначениями узлов для тегов), обеспечивая уникальность назначений в потомке.
    *   **Мутация** (`mutate`): С вероятностью `mutation_rate` тег (кроме фиксированных) перемещается на случайный соседний узел в графе. Если узел занят — происходит обмен.

5.  **Завершение:** Цикл (пункты 3-4) повторяется для `G = 50` поколений. По его окончании выбирается хромосома с наивысшим значением fitness.

## Output / Result
*   **Результат:** Словарь (map) `std::map<std::string, int> tag_assignments`, где ключ — это название тега, а значение — ID узла в графе, на который этот тег назначен.
*   **Назначение:** Этот словарь является главным руководством для движка игры при размещении конкретных игровых объектов, акторов и триггеров на карте в начале уровня..

## Feedback
*   **Логическая (для разработчика):** Основная обратная связь — это значение fitness лучшей хромосомы на каждом поколении. Его рост свидетельствует о работе алгоритма. Визуализация в виде графика сходимости могла бы быть полезным инструментом отладки.
*   **В игровом процессе:** Игрок ощущает результат работы механики через логичную и сбалансированную расстановку контента. Слишком простой или сложный уровень, "заспавненность" событий в одном месте — признаки плохой настройки параметров ГА или ограничений в `DomainDatabase.json`.

## Balance & Tunable Variables
Ключевые параметры для балансировки:
*   `population_size` (`P`): Размер популяции. Влияет на разнообразие решений и время работы (сложность `O(P)`).
*   `generations` (`G`): Количество поколений. Влияет на качество решения и время работы (сложность `O(G)`).
*   `mutation_rate`: Вероятность мутации. Слишком высокий значение превращает поиск в случайный, слишком низкий — приводит к преждевременной сходимости.
*   Параметры в `DomainDatabase.json`:
    *   `desired_distances`: Прямо влияют на то, как далеко от старта игрок встретит то или иное событие.
    *   `min_distance_constraints`: Контролируют взаимное расположение конфликтующих или связанных повествованием объектов.

## Interactions with other systems
1.  [[PLTG]]: Является поставщиком входных данных — графа локации.
2.  **База данных сценариев** (`DomainDatabase.json`): Является поставщиком правил и ограничений для размещения. Парсится перед запуском ГА.
3.  **Диалоговая система / Система квестов (Unreal Engine):** Получает на вход готовый `tag_assignments`. В момент загрузки уровня на основе этого словаря происходит спаун соответствующих акторов (NPC, врагов, объектов) на конкретных узлах карты и регистрация триггеров событий.
4.  **Система навигации ИИ:** Использует размещенный контент для построения целей и маршрутов.

## Use Case Example
1.  После генерации графа из 50 узлов система загружает `DomainDatabase.json`, из которого извлекает, что нужно разместить теги `spawn`, `asylum`, `exit`, `quest_giver_heron`, `wolf_attack_1`, `wolf_attack_4`.
2.  Определяются фиксированные узлы: `spawn_node_id = 12`, `asylum_node_id = 25` (узел с наименьшим эксцентриситетом), `exit_node_id = 47` (максимально удален от 12).
3.  ГА запускается с параметрами `P=100`, `G=50`. Функция приспособленности штрафует решения, где `quest_giver_heron` находится не в ~5 шагах от спауна, а `wolf_attack_1` и `wolf_attack_4` — не в ~2 и ~20 шагах соответственно.
4.  После 50 поколений лучшая хромосома дает результат: `{"spawn": 12, "asylum": 25, "exit": 47, "quest_giver_heron": 18, "wolf_attack_1": 5, "wolf_attack_4": 45}`.
5.  При загрузке уровня на узел 18 помещается NPC Цапля, на узлы 5 и 45 — триггеры сражений с волками.
