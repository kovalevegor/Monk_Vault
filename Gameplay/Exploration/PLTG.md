---
data: 2005-09-03T18:00:00
tags:
  - "#gameplay"
  - "#exploration"
  - "#pcg"
aliases:
  - Процедурная генерация топологии локаций
---
# Procedural Location Topology Generation

---
## Goal & Intent
Автоматическое создание уникальной, связной и сбалансированной топологии игрового пространства (графа ключевых точек, точек интереса) для каждой новой игровой сессии.

Повышение реиграбельности (`replayability`) за счет вариативности уровней, обеспечение логичной и интересной навигации для игрока, снижение затрат на ручное проектирование уровней. Механика должна создавать пространство, которое ощущается как продуманное и нерукотворное (естественное/природное), но при этом каждый раз новое.

## Trigger / Prerequisites
*   **Входные данные:** Параметры карты: `width`, `height`, `radius` (минимальный радиус между точками).
*   **Триггер:** Механика запускается один раз при инициализации новой игровой сессии, до начала gameplay или при запуске новой локации.
*   **Предварительные условия:** Наличие предопределенного набора алгоритмов (Fast Poisson Disk Sampling, Delaunay Triangulation, Kruskal's Algorithm) и структур данных (`Knot`, `Triangle`, `Edge`).

## Execution / Process
Процесс генерации является последовательным конвейером из нескольких алгоритмов:

1.  **Генерация точек интереса (POI) методом Fast Poisson Disk Sampling:**
    *   Создается сетка для оптимизации проверок.
    *   Первая точка `k0` генерируется случайно в пределах `[0, width] x [0, height]`.
    *   Пока `active` список не пуст, для каждой активной точки генерируется до `k=30` новых точек в кольце `[radius, 2*radius]`.
    *   Каждая новая точка проверяется на валидность (нахождение в границах карты и расстояние > `radius` до всех существующих точек).
    *   Валидные точки добавляются в результат и в `active` список. Невалидные – игнорируются. После `k` неудачных попыток точка удаляется из `active`.

[[Knot.h]]
[[Knot.cpp]]

2.  **Построение триангуляции Делоне алгоритмом Боуера-Ватсона:**
    *   На основе массива точек `knots` строится "супертреугольник", охватывающий все точки.
    *   Для каждой точки в `knots` находится множество "плохих" треугольников, в описанную окружность которых попадает точка.
    *   Из ребер "плохих" треугольников формируется полигон (учитываются только уникальные ребра).
    *   "Плохие" треугольники удаляются, а на их месте создаются новые путем соединения ребер полигона с текущей точкой.
    *   По завершении все треугольники, содержащие вершины "супертреугольника", удаляются.

[[Triangulation.h]]
[[Triangulation.cpp]]


3.  **Построение Минимального Остовного Дерева (MST) алгоритмом Краскала:**
    *   Все ребра, полученные из триангуляции, преобразуются в взвешенные ребра (`EdgeWithWeight`), где вес = Евклидово расстояние между точками.
    *   Ребра сортируются по весу (по возрастанию).
    *   Инициализируется структура DSU (Disjoint Set Union) для отслеживания связности.
    *   Проходим по отсортированным ребрам: если ребро соединяет две несвязные компоненты, оно добавляется в MST.

4.  **Добавление случайных ребер для вариативности:**
    *   Для повышения вариативности прохождения к ребрам MST добавляются случайные ребра из исходного набора ребер триангуляции.
    *   Вероятность добавления контролируется параметром `probability`.
    *   Добавляются только ребра, длина которых не превышает `120%` от средней длины всех ребер, чтобы избежать "длинных прыжков", нарушающих баланс.

[[MinimumSpanningTree.h]]
[[MinimumSpanningTree.cpp]]
## Output / Result
*   **Результат:** Граф `G = (V, E)`, где:
    *   `V` (Вершины) - массив точек `knots`, равномерно распределенных `std::vector<Knot>`.
    *   `E` (Ребра) - массив связей между точками, включающий ребра MST и дополнительные случайные ребра `std::vector<Edge>`.
*   **Назначение:** Этот граф служит основой (каркасом) игровой локации. Его вершины (узлы) в дальнейшем используются для размещения квестовых триггеров, врагов, ресурсов и других игровых объектов, а ребра определяют возможные пути перемещения игрока.

## Feedback
*   **Визуальная (в разработке):** В качестве прототипа предполагается создание интерактивных сфер, отражающих узлы и динамических связующих отрезков, соединяющих сферы.
*   **Логическая:** Корректность работы механизма подтверждается тестами, проверяющими:
    *   Все точки находятся на допустимом расстоянии друг от друга и в пределах доступности для пользователя.
    *   Полученный граф является связным (не имеет изолированных участков).
    *   Количество узлов и связей соответствует ожидаемому для заданных параметров.

## Balance & Tunable Variables
Ключевые параметры, влияющие на итоговый вид локации:
*   `width` & `height`: Размеры игровой области. Влияют на масштаб локации.
*   `radius`: Минимальное расстояние между точками. **Главный параметр плотности.** Уменьшение `radius` ведет к увеличению количества точек и, как следствие, к большей детализации и сложности графа.
*   `k` (в Poisson Disk): Количество попыток генерации новой точки (по умолчанию 30). Влияет на равномерность заполнения пространства и скорость работы алгоритма.
*   `probability` (добавления случайных ребер): Влияет на "ветвистость" графа. Высокие значения создают больше альтернативных путей, низкие – ведут к более линейным и предсказуемым локациям.

## Interactions with other systems
1.  **Система размещения контента (Genetic Algorithm):** Полученный граф передается на вход генетическому алгоритму ([[Генетический алгоритм размещения квестовых триггеров]]), который распределяет по узлам конкретный игровой контент, основываясь на топологии и заданных ограничениях (`desired_distances`, `min_distance_constraints`).
2.  **Навигационная система (Unreal Engine):** Граф должен быть использован для построения визуальной локации, отражающей природные формы.
3.  **Игровой цикл:** Сгенерированная топология определяет структуру уровня, по которому будет перемещаться игрок, вступать в бои ([[Адаптивные боевые сценарии]]) и взаимодействовать с объектами.

## Use Case Example
1.  Игрок запускает новую игру.
2.  Система генерации вызывает `poissonDiskSampling(5000, 5000, 300, 30)`, создавая ~200 точек на большой карте.
3.  На этих точках строится триангуляция Делоне, а затем извлекается MST, обеспечивающее связность.
4.  К MST добавляется 15% случайных ребер от исходного набора триангуляции для создания циклов и альтернативных маршрутов.
5.  Итоговый граф передается алгоритму размещения контента, который расставляет на узлах флаги для квестовых триггеров.
6.  Игрок начинает игру на узле `SPAWN` и исследует уникальную для этой сессии локацию.

## UI/UX Elements
*   В текущей реализации UI для конечного игрока отсутствует. Генерация происходит автоматически "за кулисами".
*   Для разработчиков и отладки реализована визуализация в редакторе Unreal Engine (debug-рисование линий и точек).

---
